<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Rastreamento - Macei√≥</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        #map {
            width: 100%;
            height: 100vh;
        }

        /* Painel de informa√ß√µes */
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            min-width: 250px;
            font-size: 14px;
        }

        .info-panel h3 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
        }

        .status-item {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .status-item span:first-child {
            color: #666;
        }

        .status-item span:last-child {
            font-weight: bold;
            color: #2563eb;
        }

        /* Indicador de conex√£o */
        .connection-status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ef4444;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #10b981;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Controles */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        .controls button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            margin: 0 5px;
            font-size: 14px;
        }

        .controls button:hover {
            background: #1d4ed8;
        }

        .controls button:disabled {
            background: #94a3b8;
            cursor: not-allowed;
        }

        /* √çcones personalizados de ve√≠culos */
        .vehicle-icon {
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .vehicle-moto {
            background: #3b82f6;
        }

        .vehicle-van {
            background: #f59e0b;
        }

        .vehicle-caminhao {
            background: #dc2626;
        }

        /* √çcones de pontos */
        .deposito-icon {
            background: transparent;
        }

        .hub-icon {
            background: transparent;
        }

        .cliente-icon {
            background: #dc2626;
            border-radius: 50%;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(2px);
        }

        .modal-content {
            background: white;
            margin: 5% auto;
            padding: 25px;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            position: relative;
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e5e7eb;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #1f2937;
            margin: 0;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #6b7280;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: #f3f4f6;
            color: #374151;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #374151;
            font-size: 14px;
        }

        .form-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .form-input:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .form-select {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }

        .existing-networks {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 10px;
            background: #f9fafb;
        }

        .network-item {
            padding: 8px 12px;
            border-radius: 4px;
            margin-bottom: 5px;
            cursor: pointer;
            transition: background 0.2s;
            border: 1px solid transparent;
        }

        .network-item:hover {
            background: #e5e7eb;
        }

        .network-item.selected {
            background: #dbeafe;
            border-color: #2563eb;
        }

        .network-item-name {
            font-weight: 500;
            color: #1f2937;
        }

        .network-item-info {
            font-size: 12px;
            color: #6b7280;
            margin-top: 2px;
        }

        .modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            padding-top: 15px;
            border-top: 1px solid #e5e7eb;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
        }

        .btn-secondary:hover {
            background: #e5e7eb;
        }

        .btn-primary {
            background: #2563eb;
            color: white;
        }

        .btn-primary:hover {
            background: #1d4ed8;
        }

        .btn-success {
            background: #059669;
            color: white;
        }

        .btn-success:hover {
            background: #047857;
        }

        .radio-group {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        .radio-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .radio-item input[type="radio"] {
            margin: 0;
        }

        /* Loading overlay para o modal */
        .modal-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            border-radius: 0;
        }

        .loading-content {
            text-align: center;
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            min-width: 300px;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f4f6;
            border-top: 5px solid #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            font-size: 18px;
            color: #1f2937;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .loading-subtext {
            font-size: 14px;
            color: #6b7280;
            margin-top: 8px;
        }
    </style>
</head>

<body>
    <div id="map"></div>

    <!-- Painel de informa√ß√µes -->
    <div class="info-panel">
        <h3>üöö Sistema Macei√≥</h3>
        <div class="status-item">
            <span>Ve√≠culos Ativos:</span>
            <span id="activeVehicles">0</span>
        </div>
        <div class="status-item">
            <span>Total de Rotas:</span>
            <span id="totalRoutes">0</span>
        </div>
        <div class="status-item">
            <span>√öltima Atualiza√ß√£o:</span>
            <span id="lastUpdate">-</span>
        </div>
        <div class="status-item">
            <span>Rede:</span>
            <span id="networkId">-</span>
        </div>
    </div>

    <!-- Controles -->
    <div class="controls">
        <button onclick="generateNetwork()">Carregar/Gerar Rede</button>
        <button onclick="startTracking()" id="startBtn">Iniciar Rastreamento</button>
        <button onclick="stopTracking()" id="stopBtn" disabled>Parar</button>
    </div>

    <!-- Modal para configura√ß√£o da rede -->
    <div id="networkModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">üåê Configurar Rede de Entrega</h3>
                <button class="close-btn" onclick="closeModal()">&times;</button>
            </div>

            <div class="modal-body">
                <!-- Sele√ß√£o de a√ß√£o -->
                <div class="form-group">
                    <label class="form-label">üìã Escolha uma op√ß√£o:</label>
                    <div class="radio-group">
                        <div class="radio-item">
                            <input type="radio" id="useExisting" name="networkAction" value="existing"
                                onchange="toggleNetworkOptions()">
                            <label for="useExisting">Carregar rede existente</label>
                        </div>
                        <div class="radio-item">
                            <input type="radio" id="createNew" name="networkAction" value="new" checked
                                onchange="toggleNetworkOptions()">
                            <label for="createNew">Criar nova rede</label>
                        </div>
                    </div>
                </div>

                <!-- Lista de redes existentes -->
                <div id="existingNetworksSection" class="form-group" style="display: none;">
                    <label class="form-label">üóÇÔ∏è Redes Dispon√≠veis:</label>
                    <div id="existingNetworksList" class="existing-networks">
                        <!-- Preenchido dinamicamente -->
                    </div>
                </div>

                <!-- Configura√ß√µes para nova rede -->
                <div id="newNetworkSection" class="form-group">
                    <div class="form-group">
                        <label class="form-label">üìõ Nome da Rede:</label>
                        <input type="text" id="networkName" class="form-input" placeholder="Ex: Rede Macei√≥ Centro"
                            value="Rede_Maceio">
                    </div>

                    <div class="form-group">
                        <label class="form-label">üë• N√∫mero de Clientes:</label>
                        <input type="number" id="numClients" class="form-input" min="10" max="200" value="50">
                    </div>

                    <div class="form-group">
                        <label class="form-label">üöö N√∫mero de Entregadores (opcional):</label>
                        <input type="number" id="numDeliverers" class="form-input" min="5" max="20"
                            placeholder="Autom√°tico se vazio">
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal()">Cancelar</button>
                <button id="confirmBtn" class="btn btn-primary" onclick="confirmNetworkSelection()">Criar Rede</button>
            </div>

            <!-- Loading overlay -->
            <div id="modalLoading" class="modal-loading">
                <div class="loading-content">
                    <div class="loading-spinner"></div>
                    <div class="loading-text" id="loadingText">Criando rede...</div>
                    <div class="loading-subtext" id="loadingSubtext">Aguarde enquanto a rede √© configurada</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Configura√ß√£o inicial
        let map;
        let websocket;
        let vehicles = new Map();
        let depositos = new Map();
        let hubs = new Map();
        let clientes = new Map();
        let routes = new Map();
        let isTracking = false;
        let currentNetworkId = null;
        let accessToken = null;

        // Inicializar mapa centrado em Macei√≥
        function initMap() {
            map = L.map('map').setView([-9.6658, -35.7350], 12);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);

            console.log('‚úì Mapa inicializado');
        }

        // Conectar WebSocket
        function connectWebSocket(redeId) {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const token = localStorage.getItem('accessToken');
            console.log('üîå Conectando WebSocket com token:', token ? token.substring(0, 20) + '...' : 'null');
            const wsUrl = `${protocol}//${window.location.host}/tracking/${redeId}?token=${token}`;

            try {
                websocket = new WebSocket(wsUrl);

                websocket.onopen = function (event) {
                    console.log('‚úì WebSocket conectado');
                    updateConnectionStatus(true);
                };

                websocket.onmessage = function (event) {
                    const data = JSON.parse(event.data);
                    handleWebSocketMessage(data);
                };

                websocket.onclose = function (event) {
                    console.log('‚úó WebSocket desconectado');
                    updateConnectionStatus(false);

                    // Tentar reconectar ap√≥s 5 segundos
                    if (isTracking) {
                        setTimeout(() => connectWebSocket(redeId), 5000);
                    }
                };

                websocket.onerror = function (error) {
                    console.error('‚ùå Erro WebSocket:', error);
                    updateConnectionStatus(false);
                };

            } catch (error) {
                console.error('‚ùå Erro ao conectar WebSocket:', error);
                updateConnectionStatus(false);
            }
        }

        // Atualizar status de conex√£o
        function updateConnectionStatus(connected) {
            const dot = document.getElementById('connectionDot');
            const text = document.getElementById('connectionText');
        }

        // Processar mensagens do WebSocket
        function handleWebSocketMessage(data) {
            console.log('üì® Dados recebidos:', data);

            if (data.type === 'network_update') {
                updateNetworkDisplay(data);
            } else if (data.type === 'initial_data') {
                console.log('üìä Dados iniciais recebidos:', data.data);
                if (data.data) {
                    updateNetworkDisplay(data.data);
                }
            } else if (data.type === 'network_created') {
                currentNetworkId = data.rede_id;
                document.getElementById('networkId').textContent = data.rede_id;
                console.log('‚úì Rede criada:', data.rede_id);
                loadNetworkData(data.rede_id);
            } else if (data.type === 'error') {
                console.error('‚ùå Erro do WebSocket:', data.message);
            }
        }

        // Atualizar display da rede
        function updateNetworkDisplay(data) {
            console.log('üîÑ Atualizando display da rede:', data);

            // Verificar se temos dados de rede inicial (formato exportar_dados_websocket)
            if (data.network_info && data.network_info.nodes) {
                console.log('üìä Dados iniciais da rede detectados');
                displayNetworkFromInitialData(data.network_info);
            }

            // Atualizar estat√≠sticas
            if (data.estatisticas) {
                console.log('üìä Estat√≠sticas:', data.estatisticas);

                // Atualizar ve√≠culos ativos (usar dados corretos)
                const vehiculosAtivos = data.estatisticas.veiculos?.ativos ||
                    data.estatisticas.veiculos_ativos || 0;
                document.getElementById('activeVehicles').textContent = vehiculosAtivos;

                // Atualizar rotas ativas
                const rotasAtivas = data.estatisticas.rotas?.ativas ||
                    data.estatisticas.rotas_ativas || 0;
                document.getElementById('totalRoutes').textContent = rotasAtivas;
            }

            // Atualizar timestamp
            if (data.timestamp) {
                // Converter para hor√°rio brasileiro (UTC-3)
                const timestamp = new Date(data.timestamp);
                const time = timestamp.toLocaleTimeString('pt-BR', {
                    timeZone: 'America/Sao_Paulo',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
                document.getElementById('lastUpdate').textContent = time;
            }
            // Atualizar posi√ß√µes de ve√≠culos (suporta ambos os formatos)
            let vehiclePositions = data.posicoes_veiculos || data.vehicles;
            if (vehiclePositions && vehiclePositions.length > 0) {
                console.log('üöó Posi√ß√µes de ve√≠culos recebidas:', vehiclePositions.length, 've√≠culos');
                console.log('üìç Dados dos ve√≠culos:', vehiclePositions);
                updateVehiclePositions(vehiclePositions);
            } else {
                console.log('‚ö†Ô∏è Nenhuma posi√ß√£o de ve√≠culo recebida');
                console.log('üìä Dados completos recebidos:', data);
            }
        }

        // Fun√ß√£o para processar dados iniciais da rede (formato exportar_dados_websocket)
        function displayNetworkFromInitialData(networkInfo) {
            console.log('üó∫Ô∏è Processando dados iniciais da rede:', networkInfo);

            if (networkInfo.nodes && networkInfo.nodes.length > 0) {
                console.log('üìç Processando n√≥s da rede:', networkInfo.nodes.length, 'n√≥s');

                networkInfo.nodes.forEach(node => {
                    if (node.type === 'depot') {
                        const icon = L.divIcon({
                            className: 'deposito-icon',
                            html: 'üè≠',
                            iconSize: [50, 50],
                            iconAnchor: [15, 15]
                        });

                        const marker = L.marker(node.coordinates, { icon }).addTo(map);
                        marker.bindPopup(`
                            <b>Dep√≥sito: ${node.name}</b><br>
                            Capacidade: ${node.capacity}
                        `);
                        depositos.set(node.id, marker);

                    } else if (node.type === 'hub') {
                        const icon = L.divIcon({
                            className: 'hub-icon',
                            html: 'üè¢',
                            iconSize: [50, 50],
                            iconAnchor: [12, 12]
                        });
                        const marker = L.marker(node.coordinates, { icon }).addTo(map);
                        marker.bindPopup(`
                            <b>Hub: ${node.name}</b><br>
                            Capacidade: ${node.capacity}<br>
                            Endere√ßo: ${node.endereco || ''}
                        `);
                        hubs.set(node.id, marker);

                    } else if (node.type === 'client') {
                        const icon = L.divIcon({
                            className: 'cliente-icon',
                            html: 'üë§',
                            iconSize: [15, 15],
                            iconAnchor: [7, 7]
                        });
                       
                        const demanda = Number(node.demand);
                        const marker = L.marker(node.coordinates, { icon }).addTo(map);
                        marker.bindPopup(`
                            <b>Cliente: ${node.id}</b><br>
                            Demanda: ${demanda}<br>
                        `);
                        clientes.set(node.id, marker);
                    }
                });

                console.log(`‚úì Dados iniciais carregados: ${depositos.size} dep√≥sitos, ${hubs.size} hubs, ${clientes.size} clientes`);
            }
        }

        // Atualizar posi√ß√µes dos ve√≠culos no mapa
        function updateVehiclePositions(positions) {
            console.log('üîÑ Atualizando posi√ß√µes de', positions.length, 've√≠culos');

            positions.forEach((pos, index) => {
                console.log(`üìç Ve√≠culo ${index + 1}:`, pos);

                if (vehicles.has(pos.vehicle_id)) {
                    console.log(`üîÑ Atualizando ve√≠culo existente: ${pos.vehicle_id}`);
                    const marker = vehicles.get(pos.vehicle_id);

                    // Atualizar posi√ß√£o com anima√ß√£o suave
                    marker.setLatLng([pos.latitude, pos.longitude]);

                    // Atualizar popup com informa√ß√µes
                    const updateTime = new Date(pos.timestamp).toLocaleTimeString('pt-BR', {
                        timeZone: 'America/Sao_Paulo',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                    const popup = `
                        <b>Ve√≠culo ${pos.vehicle_id}</b><br>
                        Status: ${pos.status}<br>
                        Velocidade: ${pos.speed.toFixed(1)} km/h<br>
                        Dire√ß√£o: ${pos.heading.toFixed(0)}¬∞<br>
                        Atualizado: ${updateTime}
                    `;
                    marker.setPopupContent(popup);

                } else {
                    console.log(`‚úÖ Criando novo marcador para ve√≠culo: ${pos.vehicle_id}`);
                    // Criar novo marcador de ve√≠culo
                    createVehicleMarker(pos);
                }
            });

            console.log(`üìä Total de ve√≠culos no mapa: ${vehicles.size}`);
        }

        // Criar marcador de ve√≠culo
        function createVehicleMarker(position) {
            console.log(`üöó Criando marcador para ve√≠culo ${position.vehicle_id} em [${position.latitude}, ${position.longitude}]`);

            const vehicleIcon = L.divIcon({
                className: 'vehicle-icon vehicle-moto',
                html: 'üèçÔ∏è',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });

            const marker = L.marker([position.latitude, position.longitude], {
                icon: vehicleIcon
            }).addTo(map);

            console.log(`‚úÖ Marcador criado e adicionado ao mapa para ve√≠culo ${position.vehicle_id}`);

            const updateTime = new Date(position.timestamp).toLocaleTimeString('pt-BR', {
                timeZone: 'America/Sao_Paulo',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            const popup = `
                <b>Ve√≠culo ${position.vehicle_id}</b><br>
                Status: ${position.status}<br>
                Velocidade: ${position.speed.toFixed(1)} km/h<br>
                Dire√ß√£o: ${position.heading.toFixed(0)}¬∞<br>
                Atualizado: ${updateTime}
            `;
            marker.bindPopup(popup);

            vehicles.set(position.vehicle_id, marker);
            console.log(`üìù Ve√≠culo ${position.vehicle_id} adicionado ao cache. Total: ${vehicles.size}`);
        }

        // Carregar dados da rede com retry
        async function loadNetworkData(redeId, maxAttempts = 3) {
            console.log(`üìä Carregando dados da rede ${redeId}...`);

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    console.log(`üîç Tentativa ${attempt}/${maxAttempts} - Carregando dados da rede ${redeId}...`);

                    const response = await fetch(`/api/v1/rede/${redeId}`, {
                        method: 'GET',
                        headers: getAuthHeaders(),
                        credentials: 'include'
                    });

                    if (response.ok) {
                        const rede = await response.json();
                        console.log(`‚úÖ Dados da rede ${redeId} carregados com sucesso:`, rede);
                        displayNetworkElements(rede);
                        return true; // Sucesso
                    } else {
                        console.warn(`‚ö†Ô∏è Erro ${response.status} ao carregar rede ${redeId} (tentativa ${attempt})`);

                        if (response.status === 404) {
                            throw new Error(`Rede ${redeId} n√£o encontrada`);
                        }
                    }
                } catch (error) {
                    console.error(`‚ùå Erro na tentativa ${attempt} de carregar rede ${redeId}:`, error);

                    // Se √© a √∫ltima tentativa, propagate o erro
                    if (attempt === maxAttempts) {
                        console.error(`‚ùå Falha definitiva ao carregar dados da rede ${redeId}`);
                        throw error;
                    }

                    // Aguardar antes da pr√≥xima tentativa
                    console.log(`‚è≥ Aguardando 1s antes da pr√≥xima tentativa...`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }

            return false;
        }

        // Exibir elementos da rede no mapa
        function displayNetworkElements(rede) {
            // Limpar marcadores existentes
            clearMapElements();

            // Adicionar dep√≥sitos
            rede.depositos?.forEach(deposito => {
                const icon = L.divIcon({
                    className: 'deposito-icon',
                    html: 'üè≠',
                    iconSize: [40, 40],
                    iconAnchor: [15, 15]
                });

                const marker = L.marker([deposito.latitude, deposito.longitude], {
                    icon: icon
                }).addTo(map);

                marker.bindPopup(`
                    <b>Dep√≥sito: ${deposito.nome}</b><br>
                    Capacidade: ${deposito.capacidade_maxima}<br>
                    Endere√ßo: ${deposito.endereco}
                `);

                depositos.set(deposito.id, marker);
            });

            // Adicionar hubs
            rede.hubs?.forEach(hub => {
                const icon = L.divIcon({
                    className: 'hub-icon',
                    html: 'üè¢',
                    iconSize: [40, 40],
                    iconAnchor: [12, 12]
                });

                const marker = L.marker([hub.latitude, hub.longitude], {
                    icon: icon
                }).addTo(map);

                marker.bindPopup(`
                    <b>Hub: ${hub.nome}</b><br>
                    Capacidade: ${hub.capacidade}<br>
                    Endere√ßo: ${hub.endereco}
                `);

                hubs.set(hub.id, marker);
            });
 
            const clientesAmostra = rede.clientes || [];
            clientesAmostra.forEach(cliente => {
                const icon = L.divIcon({
                    className: 'cliente-icon',
                    html: 'üë§',
                    iconSize: [15, 15],
                    iconAnchor: [7, 7]
                });

                // Forma correta: usar cliente.demanda_media e cliente.prioridade
                const demanda = cliente.demanda_media;
                const prioridade = cliente.prioridade;
                const marker = L.marker([cliente.latitude, cliente.longitude], {
                    icon: icon
                }).addTo(map);
                marker.bindPopup(`
                    <b>Cliente: ${cliente.id}</b><br>
                    Demanda: ${demanda}<br>
                    Prioridade: ${prioridade}<br>
                `);
                clientes.set(cliente.id, marker);
            });

            console.log(`‚úì Rede carregada: ${rede.depositos?.length || 0} dep√≥sitos, ${rede.hubs?.length || 0} hubs, ${clientesAmostra.length} clientes`);
        }

        // Limpar elementos do mapa
        function clearMapElements() {
            vehicles.forEach(marker => map.removeLayer(marker));
            depositos.forEach(marker => map.removeLayer(marker));
            hubs.forEach(marker => map.removeLayer(marker));
            clientes.forEach(marker => map.removeLayer(marker));

            vehicles.clear();
            depositos.clear();
            hubs.clear();
            clientes.clear();
        }

        // Gerar nova rede ou carregar existente
        async function generateNetwork() {
            console.log('üîß Fun√ß√£o generateNetwork() chamada');

            // Mostrar modal sem carregar redes automaticamente
            showNetworkModal();
        }

        // Fun√ß√£o para atualizar a lista de redes no modal j√° aberto
        function updateNetworksList(existingNetworks) {
            const existingNetworksList = document.getElementById('existingNetworksList');
            if (!existingNetworksList) {
                console.error('‚ùå Lista de redes n√£o encontrada!');
                return;
            }

            // Limpar lista anterior e mostrar loading se ainda n√£o h√° dados
            existingNetworksList.innerHTML = '';

            if (!existingNetworks || existingNetworks.length === 0) {
                existingNetworksList.innerHTML = '<div style="text-align: center; color: #6b7280; padding: 20px;">Nenhuma rede encontrada</div>';
                return;
            }

            console.log('üìã Atualizando lista com', existingNetworks.length, 'redes');
            existingNetworks.forEach(network => {
                const networkItem = document.createElement('div');
                networkItem.className = 'network-item';
                networkItem.dataset.networkId = network.id;

                // Tratar created_at corretamente
                let createdDateStr = '';
                if (network.created_at) {
                    try {
                        let date;
                        if (typeof network.created_at === 'number') {
                            // Se for um n√∫mero, assumir que j√° √© timestamp Unix em segundos
                            date = new Date(network.created_at * 1000);
                        } else if (typeof network.created_at === 'string') {
                            // Se for string, tentar parsear diretamente
                            date = new Date(network.created_at);
                        }

                        if (date && !isNaN(date.getTime())) {
                            createdDateStr = '‚Ä¢ Criada: ' + date.toLocaleDateString('pt-BR');
                        }
                    } catch (e) {
                        console.warn('Erro ao processar created_at:', network.created_at, e);
                    }
                }

                networkItem.innerHTML = `
                    <div class="network-item-name">${network.nome || network.id}</div>
                    <div class="network-item-info">
                        ${network.total_nodes || 0} n√≥s ‚Ä¢ ${network.total_edges || 0} rotas
                        ${createdDateStr}
                    </div>
                `;

                networkItem.onclick = () => selectNetworkItem(networkItem);
                existingNetworksList.appendChild(networkItem);
            });
        }

        // Fun√ß√µes do Modal
        function showNetworkModal() {
            console.log('ü™ü showNetworkModal() chamada');

            const modal = document.getElementById('networkModal');
            if (!modal) {
                console.error('‚ùå Elemento modal n√£o encontrado!');
                return;
            }

            console.log('‚úÖ Elemento modal encontrado:', modal);

            // Resetar sele√ß√µes
            const createNewRadio = document.getElementById('createNew');
            if (createNewRadio) {
                createNewRadio.checked = true;
                toggleNetworkOptions();
            } else {
                console.error('‚ùå Radio button createNew n√£o encontrado!');
            }

            // Limpar lista de redes existentes
            const existingNetworksList = document.getElementById('existingNetworksList');
            if (existingNetworksList) {
                existingNetworksList.innerHTML = '<div style="text-align: center; color: #6b7280; padding: 20px;">Selecione "Carregar rede existente" para ver as redes dispon√≠veis</div>';
            }

            // Mostrar modal
            console.log('üé≠ Definindo display do modal para block...');
            modal.style.display = 'block';

            // Verificar se realmente ficou vis√≠vel
            setTimeout(() => {
                const computedStyle = window.getComputedStyle(modal);
                console.log('üîç Estilo computado do modal - display:', computedStyle.display, 'visibility:', computedStyle.visibility);
            }, 100);
        }

        function closeModal() {
            const modal = document.getElementById('networkModal');
            modal.style.display = 'none';
        }

        function toggleNetworkOptions() {
            const useExisting = document.getElementById('useExisting').checked;
            const existingSection = document.getElementById('existingNetworksSection');
            const newSection = document.getElementById('newNetworkSection');
            const confirmBtn = document.getElementById('confirmBtn');

            if (useExisting) {
                existingSection.style.display = 'block';
                newSection.style.display = 'none';
                confirmBtn.textContent = 'Carregar Rede';
                confirmBtn.className = 'btn btn-success';

                // Carregar redes existentes apenas quando esta op√ß√£o for selecionada
                loadExistingNetworksList();
            } else {
                existingSection.style.display = 'none';
                newSection.style.display = 'block';
                confirmBtn.textContent = 'Criar Rede';
                confirmBtn.className = 'btn btn-primary';
            }
        }

        // Nova fun√ß√£o para carregar redes existentes
        async function loadExistingNetworksList() {
            const existingNetworksList = document.getElementById('existingNetworksList');
            if (!existingNetworksList) {
                console.error('‚ùå Lista de redes n√£o encontrada!');
                return;
            }

            // Mostrar loading
            existingNetworksList.innerHTML = '<div style="text-align: center; color: #6b7280; padding: 20px;">üîÑ Carregando redes...</div>';

            try {
                console.log('üîç Buscando redes existentes...');

                const listResponse = await fetch('/api/v1/rede/listar', {
                    method: 'GET',
                    headers: getAuthHeaders(),
                    credentials: 'include'
                });

                let existingNetworks = [];
                if (listResponse.ok) {
                    existingNetworks = await listResponse.json();
                    console.log('üìä Redes encontradas:', existingNetworks.length);

                    // Atualizar modal com as redes carregadas
                    updateNetworksList(existingNetworks);
                } else {
                    console.warn('‚ö†Ô∏è Erro ao buscar redes:', listResponse.status);
                    updateNetworksList([]);
                }

            } catch (error) {
                console.error('‚ùå Erro ao buscar redes:', error);
                updateNetworksList([]);
            }
        }

        function selectNetworkItem(item) {
            // Remover sele√ß√£o anterior
            document.querySelectorAll('.network-item').forEach(el => {
                el.classList.remove('selected');
            });

            // Selecionar item atual
            item.classList.add('selected');
        }

        async function confirmNetworkSelection() {
            const useExisting = document.getElementById('useExisting').checked;

            if (useExisting) {
                await loadExistingNetwork();
            } else {
                await createNewNetwork();
            }
        }

        // Fun√ß√£o para aguardar que a rede esteja totalmente criada
        async function waitForNetworkToBeReady(redeId, maxAttempts = 10, intervalMs = 1000) {
            console.log(`‚è≥ Verificando se a rede ${redeId} est√° pronta... (m√°x ${maxAttempts} tentativas)`);

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    console.log(`üîç Tentativa ${attempt}/${maxAttempts} - Verificando rede ${redeId}...`);

                    const response = await fetch(`/api/v1/rede/${redeId}/info`, {
                        method: 'GET',
                        headers: getAuthHeaders(),
                        credentials: 'include'
                    });

                    if (response.ok) {
                        const info = await response.json();
                        console.log(`‚úÖ Rede ${redeId} encontrada com ${info.total_nodes} n√≥s e ${info.total_edges} rotas`);

                        // Verificar se a rede tem dados suficientes para ser considerada "pronta"
                        if (info.total_nodes > 0 && info.total_edges > 0) {
                            console.log(`‚úÖ Rede ${redeId} est√° pronta para uso!`);
                            return true;
                        } else {
                            console.log(`‚ö†Ô∏è Rede ${redeId} existe mas ainda n√£o tem dados completos`);
                        }
                    } else if (response.status === 404) {
                        console.log(`‚è≥ Rede ${redeId} ainda n√£o foi encontrada (tentativa ${attempt}/${maxAttempts})`);
                    } else {
                        console.warn(`‚ö†Ô∏è Erro ${response.status} ao verificar rede ${redeId}`);
                    }

                    // Se n√£o √© a √∫ltima tentativa, aguardar antes da pr√≥xima
                    if (attempt < maxAttempts) {
                        console.log(`‚è≥ Aguardando ${intervalMs}ms antes da pr√≥xima verifica√ß√£o...`);
                        await new Promise(resolve => setTimeout(resolve, intervalMs));
                    }
                } catch (error) {
                    console.warn(`‚ùå Erro na tentativa ${attempt} de verificar rede ${redeId}:`, error);

                    // Se n√£o √© a √∫ltima tentativa, aguardar antes da pr√≥xima
                    if (attempt < maxAttempts) {
                        await new Promise(resolve => setTimeout(resolve, intervalMs));
                    }
                }
            }

            console.warn(`‚ö†Ô∏è Timeout: Rede ${redeId} n√£o ficou pronta ap√≥s ${maxAttempts} tentativas`);
            return false;
        }

        async function loadExistingNetwork() {
            const selectedItem = document.querySelector('.network-item.selected');

            if (!selectedItem) {
                alert('Por favor, selecione uma rede para carregar.');
                return;
            }

            const networkId = selectedItem.dataset.networkId;
            const networkName = selectedItem.querySelector('.network-item-name').textContent;

            // Mostrar loading
            const confirmBtn = document.getElementById('confirmBtn');
            const originalBtnText = confirmBtn.textContent;
            confirmBtn.disabled = true;
            confirmBtn.textContent = 'üîÑ Carregando...';

            try {
                console.log('‚úì Carregando rede existente:', networkName);

                currentNetworkId = networkId;
                document.getElementById('networkId').textContent = networkName;

                // Usar a fun√ß√£o melhorada de carregamento
                const success = await loadNetworkData(networkId);

                if (success) {
                    closeModal();
                    console.log('‚úÖ Rede carregada com sucesso:', networkName);
                } else {
                    alert('Erro ao carregar os dados da rede. Tente novamente.');
                }

            } catch (error) {
                console.error('‚ùå Erro ao carregar rede:', error);
                alert('Erro ao carregar a rede selecionada.');
            } finally {
                // Restaurar bot√£o
                confirmBtn.disabled = false;
                confirmBtn.textContent = originalBtnText;
            }
        }

        async function createNewNetwork() {
            const networkName = document.getElementById('networkName').value.trim();
            const numClients = parseInt(document.getElementById('numClients').value);
            const numDeliverers = document.getElementById('numDeliverers').value.trim();

            // Valida√ß√µes
            if (!networkName) {
                alert('Por favor, insira um nome para a rede.');
                return;
            }

            if (isNaN(numClients) || numClients < 10 || numClients > 200) {
                alert('O n√∫mero de clientes deve estar entre 10 e 200.');
                return;
            }

            if (numDeliverers && (isNaN(parseInt(numDeliverers)) || parseInt(numDeliverers) < 1 || parseInt(numDeliverers) > 20)) {
                alert('O n√∫mero de entregadores deve estar entre 1 e 20.');
                return;
            }

            // Mostrar loading overlay
            const modalLoading = document.getElementById('modalLoading');
            const loadingText = document.getElementById('loadingText');
            const loadingSubtext = document.getElementById('loadingSubtext');

            modalLoading.style.display = 'flex';
            loadingText.textContent = 'Criando rede...';
            loadingSubtext.textContent = 'Aguarde enquanto a rede √© configurada';

            // For√ßar atualiza√ß√£o do DOM
            await new Promise(resolve => setTimeout(resolve, 100));

            try {
                console.log('üîÑ Criando nova rede:', networkName);

                // Construir URL com par√¢metros
                let url = `/api/v1/rede/gerar-rede-maceio?num_clientes=${numClients}&nome_rede=${encodeURIComponent(networkName)}`;
                if (numDeliverers) {
                    url += `&num_entregadores=${parseInt(numDeliverers)}`;
                }

                const response = await fetch(url, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    credentials: 'include'
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log('üì® Resposta da API:', result);

                    if (result.status === 'success' && result.data && result.data.rede_id) {
                        const redeId = result.data.rede_id;
                        currentNetworkId = redeId;
                        document.getElementById('networkId').textContent = networkName;

                        // Atualizar loading para mostrar progresso
                        loadingText.textContent = 'Aguardando cria√ß√£o...';
                        loadingSubtext.textContent = 'Verificando se a rede est√° pronta';

                        // Aguardar que a rede seja criada completamente com retry
                        console.log('‚è≥ Aguardando que a rede seja totalmente criada...');
                        const networkReady = await waitForNetworkToBeReady(redeId, 10, 1000); // 10 tentativas, 1s intervalo

                        if (networkReady) {
                            loadingText.textContent = 'Carregando dados...';
                            loadingSubtext.textContent = 'Finalizando configura√ß√£o da rede';
                            await loadNetworkData(redeId);
                            modalLoading.style.display = 'none';
                            closeModal();
                            console.log('‚úÖ Nova rede criada e carregada com sucesso:', networkName);
                        } else {
                            console.warn('‚ö†Ô∏è Rede criada mas dados podem n√£o estar totalmente dispon√≠veis');
                            modalLoading.style.display = 'none';
                            closeModal();
                            alert('Rede criada com sucesso! Se os dados n√£o aparecerem, recarregue a p√°gina.');
                        }
                    } else {
                        console.error('‚ùå Formato de resposta inesperado:', result);
                        modalLoading.style.display = 'none';
                        alert('Erro inesperado ao criar a rede.');
                    }
                } else {
                    console.error('‚ùå Erro ao criar rede:', response.statusText);
                    modalLoading.style.display = 'none';
                    alert('Erro ao criar a rede. Tente novamente.');
                }
            } catch (error) {
                console.error('‚ùå Erro ao criar rede:', error);
                modalLoading.style.display = 'none';
                alert('Erro ao criar a rede. Verifique sua conex√£o.');
            }
        }

        // Iniciar rastreamento
        function startTracking() {
            if (!currentNetworkId) {
                alert('Carregue ou gere uma rede primeiro clicando no bot√£o "Carregar/Gerar Rede"!');
                return;
            }

            isTracking = true;
            connectWebSocket(currentNetworkId);

            // Iniciar movimento dos ve√≠culos
            fetch(`/api/v1/rede/${currentNetworkId}/start-movement`, {
                method: 'POST',
                headers: getAuthHeaders(),
                credentials: 'include'
            }).then(response => {
                if (response.ok) {
                    console.log('‚úì Movimento de ve√≠culos iniciado');
                }
            });

            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
        }

        // Parar rastreamento
        function stopTracking() {
            isTracking = false;

            if (websocket) {
                websocket.close();
                websocket = null;
            }

            // Parar movimento dos ve√≠culos
            if (currentNetworkId) {
                fetch(`/api/v1/rede/${currentNetworkId}/stop-movement`, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    credentials: 'include'
                });
            }

            updateConnectionStatus(false);
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        // Fun√ß√£o para autenticar com o sistema
        async function authenticate() {
            try {
                console.log('üîê Fazendo login...');

                const formData = new FormData();
                formData.append('username', 'admin');
                formData.append('password', 'secret');

                const response = await fetch('/api/v1/auth/login', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log('‚úì Login realizado com sucesso');

                    // Armazenar o token para usar em requisi√ß√µes futuras
                    accessToken = result.access_token;
                    localStorage.setItem('accessToken', accessToken);
                    console.log('üîë Token armazenado:', accessToken.substring(0, 20) + '...');

                    return true;
                } else {
                    console.error('‚ùå Erro no login:', response.statusText);
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Erro na autentica√ß√£o:', error);
                return false;
            }
        }

        // Fun√ß√£o auxiliar para fazer requisi√ß√µes autenticadas
        function getAuthHeaders() {
            const headers = {
                'Content-Type': 'application/json'
            };

            if (accessToken) {
                headers['Authorization'] = `Bearer ${accessToken}`;
            }

            return headers;
        }

        // Inicializar aplica√ß√£o
        document.addEventListener('DOMContentLoaded', async function () {
            initMap();

            // Fazer login primeiro
            const loginSuccess = await authenticate();

            if (loginSuccess) {
                console.log('‚úì Login realizado. Clique em "Carregar/Gerar Rede" para come√ßar.');
            } else {
                console.log('‚ùå N√£o foi poss√≠vel fazer login. Algumas funcionalidades podem n√£o funcionar.');
            }

            console.log('‚úì Aplica√ß√£o iniciada - aguardando intera√ß√£o do usu√°rio');
        });

        // Event listeners para o modal
        window.addEventListener('click', function (event) {
            const modal = document.getElementById('networkModal');
            if (event.target === modal) {
                closeModal();
            }
        });

        // Fechar modal com ESC
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                closeModal();
            }
        });

        // Limpar recursos ao fechar p√°gina
        window.addEventListener('beforeunload', function () {
            stopTracking();
        });
    </script>
</body>

</html>